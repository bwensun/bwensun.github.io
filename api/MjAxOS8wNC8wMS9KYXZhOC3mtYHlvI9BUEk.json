{"title":"Java8 流式API","date":"2019-04-01T07:18:02.000Z","date_formatted":{"ll":"Apr 1, 2019","L":"04/01/2019","MM-DD":"04-01"},"link":"2019/04/01/Java8-流式API","tags":["Lamda"],"categories":["java8"],"updated":"2019-04-01T14:33:52.813Z","content":"<h4 id=\"为什么引入流式api\">为什么引入流式API<a href=\"#为什么引入流式api\" title=\"为什么引入流式API\"></a></h4><p>在java中对于数据的操作常常是借助数据库来做到的，java自带的集合操作方法是不能对于大数据量的数据进行各种操作，常常要做的就是遍历再遍历，另外java中集合操作无法支持并行执行，流式API的出现可以发挥多核处理器的优势</p>\n<a id=\"more\"></a><h4 id=\"使用\">使用<a href=\"#使用\" title=\"使用\"></a></h4><h5 id=\"构建stream\">构建<code>stream</code><a href=\"#构建stream\" title=\"构建stream\"></a></h5><ol><li><p>静态工厂方法(Stream)</p>\n<ol><li><p><code>of方法</code><br>方法参数也可以将数组或者集合，转换为流,Java中流对象只有IntStream，DoubleStream和StringStream</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntStream intStream = of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>generate方法</code></p>\n<p>该方法用于随机数产生，或者常量Stream等，返回无限长度的流最好借助lambda表达式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Double&gt; stream2 = Stream.generate(() -&gt; Math.random());</span><br><span class=\"line\">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>iterate方法</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>, x -&gt; x++);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>empty方法</code>：返回一个一个空的流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Object&gt; empty = Stream.empty();</span><br></pre></td></tr></table></figure></li>\n</ol></li>\n<li><p>集合和数组调用stream()方法</p>\n<h5 id=\"stream的操作\"><code>stream</code>的操作<a href=\"#stream的操作\" title=\"stream的操作\"></a></h5></li>\n</ol><p>流的操作分为两种：</p>\n<ol><li><code>Intermediate</code>： <code>map</code> 、<code>filter</code>、 <code>distinct</code>、 <code>sorted</code>、 <code>peek</code>、 <code>limit</code>、 <code>skip</code>、 <code>parallel</code>、 <code>sequential</code></li>\n<li><code>Terminal</code>：<code>forEach</code>、 <code>forEachOrdered</code>、 <code>toArray</code>、 <code>reduce</code>、 <code>collect</code>、 <code>min</code>、 <code>max</code>、 <code>count</code>、<code>iterator</code><br>Intermediate中间操作不会导致流的消失，返回值为stream，Terminal操作结束后流即消失了</li>\n</ol><h5 id=\"stream使用示例\"><code>stream</code>使用示例<a href=\"#stream使用示例\" title=\"stream使用示例\"></a></h5><p>demo数据如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"孙博文\"</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"孙博文\"</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"孙博文\"</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"张三\"</span>, <span class=\"number\">11</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"张三\"</span>, <span class=\"number\">12</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"张三\"</span>, <span class=\"number\">13</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"李文博\"</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"李文博\"</span>, <span class=\"number\">22</span>));</span><br><span class=\"line\">   list.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"李文博\"</span>, <span class=\"number\">23</span>));</span><br></pre></td></tr></table></figure><p><strong>map</strong>：输入流中元素执行操作后一一映射输出流的元素，这个经常会用到，尤其是再将对象的集合转变为对象中属性的集合，另外<code>map</code>经常和<code>reduce</code>操作混合使用来归并数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ageList1 = list.stream().map(x -&gt; x.getAge()).collect(Collectors.toList());</span><br><span class=\"line\">List&lt;Integer&gt; ageList2 = list.stream().map(User::getAge).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>filter</strong>：条件为布尔值，将满足条件的过滤出来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; collect = list.stream().filter(x -&gt; x.getAge() &gt; <span class=\"number\">0</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>distinct</strong>：去重，就可以看作放到set集合之中，但有序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.stream().distinct().forEach(x-&gt; System.out.println(x));</span><br></pre></td></tr></table></figure><p><strong>sorted</strong>：排序，基本数据类型是可以比较的（我没测全），对象直接比较会报错，需要自己实现比较器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">      list1.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">      list1.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">      list1.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">      list1.stream().sorted().forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\"> </span><br><span class=\"line\">      list.stream().map(User::getName).sorted().forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">       </span><br><span class=\"line\">      list.stream().sorted((x, y)-&gt;(x.getName().compareToIgnoreCase(y.getName()))).forEach(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure><p><strong>peek</strong>：用的不多，一般用来查看元素和打印元素，他和foreach的区别在于它只是中间操作，流依然存在</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList1 = list.stream().distinct().peek(x -&gt; System.out.println(x)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>limit/skip</strong>：截断流，区别在于<code>limit</code>截取前几个元素返回流，而<code>skip</code>是跳过前几个元素返回流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.stream().limit(<span class=\"number\">6</span>).skip(<span class=\"number\">3</span>).forEach(x -&gt; System.out.println(x.getName()));</span><br></pre></td></tr></table></figure><p><strong>parallel/sequential</strong>：并行流和串行流的互转，<code>parallel</code>将串行流转换为并行流，<code>sequential</code>将并行流转换为串行流，并行流不在乎保持最终的次序，所以更加快，但有时候顺序可能有误，串行流会维持最初的顺序，我用的不多</p>\n<hr>\n<p><strong>forEach</strong>：和peek类似只是为终端操作</p>\n<p><strong>forEachOrdered</strong>：foreach+sorted</p>\n<p><strong>toArray</strong>：归并流为数组<br><strong>reduce</strong>：可以理解为将初始值，按照一定的规则，对每一个流中的元素迭代的执行，直至到最后，使用非常广泛，它的完整版接受三个参数：<code>reduce(identity, accumulator, combiner)</code>,第一个参数为初始值，第二个为迭代操作，第三个为多个迭代结果的合并操作，另外两个方法都是其简略版,(<code>accumulator</code>)和(<code>identity</code>,<code>accumulator</code>)，事实上<code>min</code>,<code>max</code>,<code>count</code>都是<code>reduce</code>操作,值得注意的是combiner的作用是将并行流的处理结果归并时的执行策略，我基本不用，也不说了，免得写错了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求和(因为没有初始值，可能出现null，所以返回的optional)</span></span><br><span class=\"line\">Integer sum1 = list.stream().map(User::getAge).reduce(Integer::sum).get();</span><br><span class=\"line\"><span class=\"comment\">//完整版</span></span><br><span class=\"line\">Integer sum2 = list.stream().map(User::getAge).reduce(<span class=\"number\">0</span>, (x, y) -&gt; y = y + x);</span><br><span class=\"line\"><span class=\"comment\">//求最小值</span></span><br><span class=\"line\">list.stream().map(User::getAge).reduce(Integer::min).get();</span><br><span class=\"line\"><span class=\"comment\">//求最大值</span></span><br><span class=\"line\">list.stream().map(User::getAge).reduce(Integer::max).get();</span><br><span class=\"line\"><span class=\"comment\">//字符串拼接</span></span><br><span class=\"line\">String s = list.stream().map(User::getName).reduce(String::concat).get();</span><br></pre></td></tr></table></figure><p><strong>max/min</strong>：如上所述，一种特殊的reduce操作，取出最大或者最小值，用法较简单</p>\n<p><strong>match</strong>：返回值为布尔类型，它包括有allMatch(全部满足返回true），anyMatch(任意一个满足返回true),noneMatch(没有一个满足返回true)</p>\n<p><strong>collect</strong>：它和reduce一样重要，将流的结果处理为定义的类型，继续介绍完整版方法<code>collect(supplier, accumulator, combiner)</code></p>\n<p>对于list而言，第一个为想要获取的结果类型，使用new语法获取对象；第二个为将当前元素添加到目标中的方法；第三个为将修改后的对象转为自定义对象方法；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载版</span></span><br><span class=\"line\">List&lt;Integer&gt; ageList1 = list.stream().map(x -&gt; x.getAge()).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">//完整版</span></span><br><span class=\"line\">ArrayList&lt;User&gt; users = list.stream().collect(ArrayList&lt;User&gt;::<span class=\"keyword\">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure><p>对于map集合而言，第一个参数为key的映射，第二个为value的映射，第三个为key相同时的处理策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.stream().collect(Collectors.toMap(User::getName, User::getAge, (K1, K2) -&gt; K1));</span><br></pre></td></tr></table></figure><h4 id=\"进阶用法\">进阶用法<a href=\"#进阶用法\" title=\"进阶用法\"></a></h4><h5 id=\"直接分组\">直接分组<a href=\"#直接分组\" title=\"直接分组\"></a></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String,List&lt;User&gt;&gt;collect=list.stream().collect(Collectors.groupingBy(x-&gt;x.getName()));</span><br></pre></td></tr></table></figure><h5 id=\"按照姓名分组计数求和\">按照姓名分组计数求和<a href=\"#按照姓名分组计数求和\" title=\"按照姓名分组计数求和\"></a></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"comment\">//这是个重载的方法</span></span><br><span class=\"line\">        Map&lt;String, Long&gt; collect1 = list.stream().</span><br><span class=\"line\">                collect(Collectors.groupingBy(x -&gt; x.getName(), Collectors.counting()));</span><br><span class=\"line\">        Map&lt;String, Integer&gt; collect2 = list.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(x -&gt; x.getName(), Collectors.summingInt(user -&gt; user.getAge())));</span><br></pre></td></tr></table></figure><h5 id=\"collectandthen迭代生成流的处理：它比前者要多出一个流处理位置\">collectAndThen迭代生成流的处理：它比前者要多出一个流处理位置<a href=\"#collectandthen迭代生成流的处理：它比前者要多出一个流处理位置\" title=\"collectAndThen迭代生成流的处理：它比前者要多出一个流处理位置\"></a></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"comment\">//组内top值</span></span><br><span class=\"line\">        list.stream().</span><br><span class=\"line\">                collect(Collectors.groupingBy(User::getName,Collectors.maxBy(Comparator.comparingInt(User::getAge))))</span><br><span class=\"line\">                .forEach((name, maxAge) -&gt; System.out.println(<span class=\"string\">\"姓名：\"</span>+name+ <span class=\"string\">\"----\"</span>+ <span class=\"string\">\"最大年龄\"</span> + maxAge.get().getAge()));</span><br><span class=\"line\">        list.stream()</span><br><span class=\"line\">                .collect(Collectors</span><br><span class=\"line\">                        .groupingBy(User::getName, Collectors</span><br><span class=\"line\">                                .collectingAndThen(Collectors.maxBy(Comparator.comparingInt(User::getAge)), x-&gt;x.get().getAge())))</span><br><span class=\"line\">                .forEach((name, maxAge) -&gt; System.out.println(<span class=\"string\">\"姓名：\"</span>+name+ <span class=\"string\">\"----\"</span>+ <span class=\"string\">\"最大年龄\"</span> + maxAge));</span><br></pre></td></tr></table></figure><h4 id=\"相关\">相关<a href=\"#相关\" title=\"相关\"></a></h4><ol><li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html\" target=\"_blank\">Java 8 中的 Streams API 详解</a></li>\n</ol>","prev":{"title":"Hello World","link":"2020/05/26/hello-world"},"next":{"title":"HEXO使用","link":"2019/02/23/Hexo使用"},"plink":"http://yoursite.com/2019/04/01/Java8-流式API/"}