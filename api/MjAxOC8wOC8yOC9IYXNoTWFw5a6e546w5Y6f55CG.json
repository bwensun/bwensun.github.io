{"title":"HashMap实现原理","date":"2018-08-28T14:04:53.000Z","date_formatted":{"ll":"Aug 28, 2018","L":"08/28/2018","MM-DD":"08-28"},"link":"2018/08/28/HashMap实现原理","tags":["HashMap"],"categories":["基础"],"updated":"2019-04-01T06:31:52.833Z","content":"<h4 id=\"前言\">前言<a href=\"#前言\" title=\"前言\"></a></h4><p>今天去面试，之前也没有做什么准备，拿到面试题中有一题感觉很熟悉但是我不会，HashMap实现原理，回来后在网上看了一些文章，讲的还是比较详细的。</p>\n<a id=\"more\"></a><h4 id=\"hash表\">Hash表<a href=\"#hash表\" title=\"Hash表\"></a></h4><p>Hash表可以看作是一个综合考量的结果，我们知道数组是连续空间储存，是可以根据下标来找到相关的元素的，而链表是通过指针来指向其他的元素，对于一个元素来说只会知道相邻的元素是什么，在Java里面代表就是ArrayList和LinkedList，Hash表即横向为数组纵向为链表的形式，综合考量了查询以及插入和删除的速度。</p>\n<h4 id=\"hashmap\">HashMap<a href=\"#hashmap\" title=\"HashMap\"></a></h4><h5 id=\"node\">Node<a href=\"#node\" title=\"Node\"></a></h5><p>HashMap是存储键值对的集合，看了HashMap源码可以知道，事实上它是存储元素Node的数组，而Node实现了Map.Entry&lt;K, V&gt;接口，也就是说他可以看作是一个Entry数组。Node的构造分别由key、value、hash、和next而来</p>\n<p><code>key</code>和value<code>分别是</code>Node的键值</p>\n<p><code>hash</code>是有静态方法生成（见下方代码），若key是null，hash为0，不为null，<code>hash</code>是对<code>h</code>(key的hashcode值)和h移位16进行异或运算获得，原因后文解释</p>\n<p><code>next</code>是该索引下下一个Node的引用，指向下一个Node，next可以为null值，表示该索引下只有一个元素。</p>\n<h5 id=\"构造\">构造<a href=\"#构造\" title=\"构造\"></a></h5><p>JDK的API表示HashMap可以指定初始容量 <code>initialCapacity</code> 和负载因子<code>loadFactory</code>，不指定则默认分别为16和0.75，初始容量制定了初始Node的数组大小，负载因子表示数组容量达到满溢的比例，当数组装满就会触发resize，扩容数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态内部类Node</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hash的获取</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">//按位操作符，异或表示两者有一个是1，但不全为1，即为1，其他为0</span></span><br><span class=\"line\">    <span class=\"comment\">//移位操作符，无符号右移16位</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>补充一下移位操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;\t左移运算符\t相当于整个二进制数相对于小数点左移，即乘以2的次幂</span><br><span class=\"line\">&gt;&gt;\t右移运算符\t相当于整个二进制数相对于小数点右移，即除以2的次幂的商</span><br><span class=\"line\">&gt;&gt;&gt;\t无符号右移\t忽略符号位，空位都以0补齐</span><br><span class=\"line\"></span><br><span class=\"line\">对于正数来说&lt;&lt;&lt;和&lt;&lt;是一样的，但是对于负数来说，右移后的高位，&lt;&lt;是补上1，&lt;&lt;&lt;补上0</span><br><span class=\"line\">举个栗子：</span><br><span class=\"line\">-23在byte下的二进制表示为11101001，由23(00010111)取反加一得来</span><br><span class=\"line\">-23&gt;&gt;2 &#x3D; 11111010 &#x3D; -122</span><br><span class=\"line\">-23&gt;&gt;&gt;2 &#x3D; 58</span><br><span class=\"line\">可见区别无符号右移变味了正数</span><br></pre></td></tr></table></figure><h4 id=\"hashmap实现\">HashMap实现<a href=\"#hashmap实现\" title=\"HashMap实现\"></a></h4><h5 id=\"key的索引生成策略\">KEY的索引生成策略<a href=\"#key的索引生成策略\" title=\"KEY的索引生成策略\"></a></h5><ol><li>对key取hashcode，得到h</li>\n<li>对h和h右移16位进行异或运算，得到hash</li>\n<li>hash对Node数组长度取模，得到索引</li>\n</ol><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取key的索引</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK1.7的源码，1.8的没找到。。。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h5 id=\"putget过程\">put/get过程<a href=\"#putget过程\" title=\"put/get过程\"></a></h5><p>无论是put还是get,都需要先计算索引，获取到索引后，put先查看该索引下是否为null,如果是则直接插入，如果不为null，继续判断该Node是否存在现插入的key,存在则直接覆盖，不存在则先判断是链表还是红黑树，开始遍历，同样判定Node是否存在现插入的key，有则覆盖，无则插入到头部，期间一旦元素个数超过8个，都会转换为红黑树结构。</p>\n<p>get先检查Node数组状态，到了到索引位置后，先判定第一个元素hash值是否相等，有直接取出，没有判定数据结构遍历一一比对，这里用到了逻辑操作符的短路特点，若hash不一致也没必要继续判定了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h5 id=\"两个问题\">两个问题<a href=\"#两个问题\" title=\"两个问题\"></a></h5><ol><li><p>为什么要对h进行右移16位的异或运算，不能直接以hashcode作为key来使用？</p>\n</li>\n<li><p>为什么取模是h &amp; (length-1)，不应该直接是h%length ？</p>\n<p>首先第一个问题，hashcode这个是通过hashcode()获取的，其结果是一个int型整数，而int的取值为-2^31-2^31,接近40亿，内存很难放下，设计者还认为这样的hashcode值还不足以分布均匀，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)是为了让低位区和高位区异或来融合各自的随机特性（16正好是32的一半），让hash变得更加的散<br>第二的取模问题是因为容量一直2的次幂，length-1转换为一定是类似于0000000000001111的n个0和根号length个1，二者进行按位与运算后就获得了低位hash,而这恰恰是取模的余数，这样计算更加快捷</p>\n</li>\n</ol><h5 id=\"resize\">RESIZE<a href=\"#resize\" title=\"RESIZE\"></a></h5><p>当数组充满时就会触发扩容，数组长度变为之前的两倍，这个时候原来的索引就要重新计算，但是在HashMap这里同样有了小小的优化。</p>\n<p>先说结论：重排后的索引要么时原位置，要么是原索引+原数组长度</p>\n<p>原因：由于它的数组长度为2的次幂，计算到hash都是没有变化的，假设length = 2^k，取模时，之前的(2^k - 1)&amp;hash变成了(2^(k+1) - 1 )&amp;length，这里可以看出后者比前者大了2^k，那么都减一后后者会比前者多一个1，和hash进行按位与运算时，若hash该位置是1，那最后该位就是1，hash为0，最后就为0，转换为十进制就是一个原数组长度的区别。</p>\n<h4 id=\"相关\">相关<a href=\"#相关\" title=\"相关\"></a></h4><ol><li><a href=\"http://www.importnew.com/27043.html\" target=\"_blank\">HashMap 实现原理</a></li>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6059914.html\" target=\"_blank\">HashMap实现原理及源码分析</a></li>\n<li><a href=\"https://monkeysayhi.github.io/2017/08/26/HashMap实现原理\" target=\"_blank\">HashMap实现原理</a></li>\n</ol>","prev":{"title":"存储引擎:InnoDB和MyISAM","link":"2018/09/05/存储引擎：InnoDB和MyISAM"},"plink":"http://yoursite.com/2018/08/28/HashMap实现原理/"}