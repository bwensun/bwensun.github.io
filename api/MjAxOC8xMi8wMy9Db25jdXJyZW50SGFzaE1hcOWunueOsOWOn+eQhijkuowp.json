{"title":"ConcurrentHashMap实现原理（二）","date":"2018-12-03T07:52:53.000Z","date_formatted":{"ll":"Dec 3, 2018","L":"12/03/2018","MM-DD":"12-03"},"link":"2018/12/03/ConcurrentHashMap实现原理(二)","tags":["ConcurrentHashMap"],"categories":["基础"],"updated":"2019-02-24T07:29:48.412Z","content":"<h3 id=\"扩容\">扩容<a href=\"#扩容\" title=\"扩容\"></a></h3><p>继续接上文，分析扩容的原理，这里我没能完全弄懂他做了什么，一些问题也记录下来希望以后可以找到答案</p>\n<p><code>ConcurrentHashMap</code> 的扩容是支持并发的，可以大致分为三个步骤：</p>\n<a id=\"more\"></a><ol><li><h5 id=\"扩容准备\">扩容准备<a href=\"#扩容准备\" title=\"扩容准备\"></a></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TRANSFER_STRIDE = <span class=\"number\">16</span>;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = tab.length, stride;</span><br><span class=\"line\">    <span class=\"comment\">//核数越大，就取(n &gt;&gt;&gt; 3) / NCPU，显然这个值会很小（如果n=16的话），没理解</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stride = (NCPU &gt; <span class=\"number\">1</span>) ? (n &gt;&gt;&gt; <span class=\"number\">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class=\"line\">        stride = MIN_TRANSFER_STRIDE; <span class=\"comment\">// subdivide range</span></span><br><span class=\"line\">    <span class=\"comment\">//这里判断为null,确保只有一个线程获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextTab == <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// initiating</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\">            nextTab = nt;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;      <span class=\"comment\">// try to cope with OOME</span></span><br><span class=\"line\">            sizeCtl = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextTable = nextTab;</span><br><span class=\"line\">        transferIndex = n;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p><code>NCPU</code>是 返回可用处理器的Java虚拟机的数量</p>\n<p><code>stride</code>可以译为步幅，代表一个线程处理的节点数量，最小为16，在对多核处理器时，可以允许更大的步幅</p>\n<p><code>transferIndex</code>表示每次迁移任务的下标(从后往前)，如果是第一次那么为<code>transferIndex</code>到<code>transferIndex - stride</code>，每次任务分配完毕会被修改</p>\n<p>这一步定义了之后会用到的相关变量，并允许有且只有一条线程来创建新的Node数组，方便迁移</p>\n</li>\n<li><h5 id=\"迁移任务分配\"><strong>迁移任务分配</strong><a href=\"#迁移任务分配\" title=\"迁移任务分配\"></a></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForwardingNode&lt;K,V&gt; fwd = <span class=\"keyword\">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class=\"line\">boolean advance = <span class=\"literal\">true</span>;</span><br><span class=\"line\">boolean finishing = <span class=\"literal\">false</span>; <span class=\"comment\">// to ensure sweep before committing nextTab</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>, bound = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; f; int fh;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (advance) &#123;</span><br><span class=\"line\">        int nextIndex, nextBound;</span><br><span class=\"line\">        <span class=\"comment\">//--i &gt;= bound代表的含义是不满足则表示代表当前任务完成，需要将i减一，然后advance设置为false,意为分配下一个任务，第一次进入就是这样，finishing为true代表整个扩容操作完成，自然不需要再操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--i &gt;= bound || finishing)</span><br><span class=\"line\">            advance = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果transferIndex&lt;0证明区间任务已经分配完毕，将advance设置为false,退出while循环，i设置为-1，在下方的if与剧中判断</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((nextIndex = transferIndex) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            i = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            advance = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//CAS分配任务给各个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt</span><br><span class=\"line\">                 (<span class=\"keyword\">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class=\"line\">                  nextBound = (nextIndex &gt; stride ?</span><br><span class=\"line\">                               nextIndex - stride : <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//最小下标</span></span><br><span class=\"line\">            bound = nextBound;</span><br><span class=\"line\">            <span class=\"comment\">//最大下标</span></span><br><span class=\"line\">            i = nextIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            advance = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//i&lt;0只可能是进入上面的第一种或者第二种情况，代表扩容结束或者分配完毕</span></span><br><span class=\"line\">    <span class=\"comment\">//i &gt;= n感觉不可能出现这种情况，如前所述，那么只有i = nextIndex - 1这里赋值修改了i，而n就是table的长度，nextIndex只会越来越小</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class=\"line\">        int sc;</span><br><span class=\"line\">        <span class=\"comment\">//如果扩容完成</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finishing) &#123;</span><br><span class=\"line\">            nextTable = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            table = nextTab;</span><br><span class=\"line\">            sizeCtl = (n &lt;&lt; <span class=\"number\">1</span>) - (n &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果扩容未完成，修改sc的值，表示的协助扩容的线程数-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc = sizeCtl, sc - <span class=\"number\">1</span>)) &#123;\t\t\t\t<span class=\"comment\">//不等于代表扩容未结束，直接return退出方法，否则就更新finishing表示扩容结束</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sc - <span class=\"number\">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            finishing = advance = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i = n; <span class=\"comment\">// recheck before commit</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取旧table的i位置的节点，如果是null,插入fwd表示已经扩容了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i)) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        advance = casTabAt(tab, i, <span class=\"literal\">null</span>, fwd);</span><br><span class=\"line\">    <span class=\"comment\">//如果hash值是moved证明已被处理过，因为moved是表示该节点正在扩容，证明以有线程处理了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">        advance = <span class=\"literal\">true</span>; <span class=\"comment\">// already processed</span></span><br></pre></td></tr></table></figure><p><code>ForwardingNode</code> 前面说过表示该节点正在被迁移，在扩容之中，假设tableA中的i位置的节点正在或者已经被迁移到TableB中，那么i位置就会被放上一个<code>ForwardingNode</code>表示已经被迁移</p>\n<p><code>advance</code> 任务分配标识，true表示经分配完当前任务</p>\n<p><code>finishing</code> 扩容完成标识, true标识扩容完成</p>\n<p><code>i</code> 是位置索引，<code>bound</code> 是当前线程可以处理的当前任务区间最小下标</p>\n</li>\n<li><h5 id=\"迁移\">迁移<a href=\"#迁移\" title=\"迁移\"></a></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//再次判断节点是否相同</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    Node&lt;K,V&gt; ln, hn;</span><br><span class=\"line\">                    <span class=\"comment\">//因为TreeBin 的 hash 是 -2，所以这里true代表是链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//这里结果只有两种一种是0一种为第n位为1的某个数</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> runBit = fh &amp; n;</span><br><span class=\"line\">                        <span class=\"comment\">//将第i位的节点复制给lastRun</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class=\"line\">                        <span class=\"comment\">//遍历这个链表 </span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class=\"keyword\">null</span>; p = p.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> b = p.hash &amp; n;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (b != runBit) &#123;</span><br><span class=\"line\">                                runBit = b;</span><br><span class=\"line\">                                lastRun = p;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (runBit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            ln = lastRun;</span><br><span class=\"line\">                            hn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            hn = lastRun;</span><br><span class=\"line\">                            ln = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((ph &amp; n) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                                ln = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hn = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        setTabAt(nextTab, i, ln);</span><br><span class=\"line\">                        setTabAt(nextTab, i + n, hn);</span><br><span class=\"line\">                        setTabAt(tab, i, fwd);</span><br><span class=\"line\">                        advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; lo = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; hi = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> lc = <span class=\"number\">0</span>, hc = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> h = e.hash;</span><br><span class=\"line\">                            TreeNode&lt;K,V&gt; p = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;</span><br><span class=\"line\">                                (h, e.key, e.val, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((h &amp; n) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((p.prev = loTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    lo = p;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = p;</span><br><span class=\"line\">                                loTail = p;</span><br><span class=\"line\">                                ++lc;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((p.prev = hiTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hi = p;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = p;</span><br><span class=\"line\">                                hiTail = p;</span><br><span class=\"line\">                                ++hc;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class=\"line\">                            (hc != <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class=\"line\">                            (lc != <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class=\"line\">                        setTabAt(nextTab, i, ln);</span><br><span class=\"line\">                        setTabAt(nextTab, i + n, hn);</span><br><span class=\"line\">                        setTabAt(tab, i, fwd);</span><br><span class=\"line\">                        advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ol><li>其他情况表示该节点不为null,也没有moved,则将该节点锁住，防止其他线程在往其中插入数据</li>\n<li>判断该节点是链表还是红黑树，分别处理</li>\n<li>当为链表时，根据和<code>table.length</code>的<code>与运算</code>可以将链表一分为二</li>\n</ol></li>\n</ol>","prev":{"title":"HEXO使用","link":"2019/02/23/Hexo使用"},"next":{"title":"ConcurrentHashMap实现原理（一）","link":"2018/12/01/ConcurrentHashMap实现原理(一)"},"plink":"http://yoursite.com/2018/12/03/ConcurrentHashMap实现原理(二)/","toc":[{"id":"扩容","title":"扩容","index":"1"}]}