{"pages":[],"posts":[{"title":"ConcurrentHashMap实现原理（一）","text":"前言最近闲下来，接着把自己所理解的一些内容做个整理，接着上次的HashMap继续看ConcurrentHashMap的源码，探究下其实现原理，源码用的JDK1.8版本。 ConcurrentHashMap和HashMap区别在于ConcurrentHashMap是线程安全的，它内部维护了多个Segment，各个Segment内部包含了Node节点，也就是键值对的集合，对外部来说，并发读写只会阻塞某个Segment而不会影响到其他，兼顾了线程安全和访问速度。 初始化ConcurrentHashMap的初始化 123456789101112131415161718192021222324252627282930 //initialCapacity 初始容量，不指定默认为16，相当于Node节点的初始化数组长度//loadFactor 负载因子，不指定默认为0.75，达到initialCapacity * loadFactor 会触发扩容//concurrencyLevel 并发级别，不指定默认为1，//private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30//若大于最大值则为最大值，若不为2的幂就转变为大于入参的最小2的幂public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; } sizeCtl：控制标识符， 负数代表正在进行初始化或扩容操作 -1代表正在初始化或扩容 -N 表示有N-1个线程正在进行扩容操作 正数或0代表hash表还没有被初始化，初始化完毕后代表扩容阈值。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的 Segment: 12345static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { private static final long serialVersionUID = 2249069246763182397L; final float loadFactor; Segment(float lf) { this.loadFactor = lf; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.val = val; this.next = next; } public final K getKey() { return key; } public final V getValue() { return val; } public final int hashCode() { return key.hashCode() ^ val.hashCode(); } public final String toString(){ return key + \"=\" + val; } public final V setValue(V value) { throw new UnsupportedOperationException(); } public final boolean equals(Object o) { Object k, v, u; Map.Entry&lt;?,?&gt; e; return ((o instanceof Map.Entry) &amp;&amp; (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp; (v = e.getValue()) != null &amp;&amp; (k == key || k.equals(key)) &amp;&amp; (v == (u = val) || v.equals(u))); } /** * Virtualized support for map.get(); overridden in subclasses. */ Node&lt;K,V&gt; find(int h, Object k) { Node&lt;K,V&gt; e = this; if (k != null) { do { K ek; if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek)))) return e; } while ((e = e.next) != null); } return null; }} PUT过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public V put(K key, V value) { return putVal(key, value, false);}/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh &gt;= 0) { binCount = 1; for (Node&lt;K,V&gt; e = f;;++binCount) { K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null;} 首先判定key，value是否有null值，有则抛出异常 获取key的hashcode值暂记为hashcode,计算hashcode异或运算hashcode无符号右移16位后在和HASH_BIT与运算，获取hash值，0x7fffffff为最大的INT数值，相当2^31-1 1234 static final int spread(int h) { return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; }static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash 判定Node节点数组table是否存在，不存在则初始化table 1transient volatile Node&lt;K,V&gt;[] table; 12345678910111213141516171819202122private final Node&lt;K,V&gt;[] initTable() { Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) { if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); } } finally { sizeCtl = sc; } break; } } return tab;} 初始化过程 sizeCtl是状态标识，小于零代表已有线程正在进行初始化操作，其他线程进入阻塞状态，第二次判断，这里使用的是CAS来保证线程安全 初始化容量小于0，修正为默认容量，最后计算的出sizeCtl新的阈值 判断是否是第一次插入，是就通过CAS来直接替换内存中的值 前面了解了HashMap的可以知道(n - 1) &amp; hash就是table中的索引值（在hashMap里面解释了原因），这里还有个原因为什么使用Unsafe中的getObjectVolatile方法，不直接通过索引来获取呢？原因是getObjectVolatile获取的是内存中的最新的值，而用索引获取哪怕是用了volite关键字修饰,但是线程中储存的一直是副本值，依旧存在旧值的可能。 static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) { return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE); } &lt;!--￼7--&gt; 确认第一次插入的情况下，CAS执行更新 第三种情况，当table的hash值为一个特殊值MOVED,表示当前哈希表正在执行resizing操作，需要当前线程去帮组做resizing操作 1234567891011121314151617181920212223final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) { Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) { int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) { if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) { transfer(tab, nextTab); break; } } return nextTab; } return table;} static final int resizeStamp(int n) { return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));} ForwardingNode—— A node inserted at head of bins during transfer operations.他是在扩容操作中的一个插入在桶头部的特殊节点，他的含义表明，这个桶已经完成了扩容操作，但是整个哈希表扩容操作还没有结束，如果检测到这种节点，当前线程会被要求一起来完成部分扩容操作 首先检测是否存在ForwardingNode resizeStamp(tab.length) 获取一个16位的扩容标识， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) { // initiating try { @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } int nextn = nextTab.length; ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) { Node&lt;K,V&gt; f; int fh; while (advance) { int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { int sc; if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; } if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else { synchronized (f) { if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) { int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } else if (f instanceof TreeBin) { TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } }} 第四种情况，通常情况的一般处理 先对table进行加锁处理，再次确认值未被修改 判断fh（table的hash值）大于0标识，该table为链表结构，key值相等则替换，onlyIfAbsent只有缺失才替换，这里也用到了&amp;&amp;的短路特性 当fh（table的hash值）不大于0,判断是否为树形结构，1.8在多数据的时候会转变为红黑树，替换对应的value值即可 最后链表插入完成后会再次检测插入数量是否超过 8个时，是则会转化成红黑树结构存储 相关： java8—ConcurrentHashMap实现原理 Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析","link":"/2018/12/01/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(%E4%B8%80)/"},{"title":"ConcurrentHashMap实现原理（二）","text":"扩容继续接上文，分析扩容的原理，这里我没能完全弄懂他做了什么，一些问题也记录下来希望以后可以找到答案 ConcurrentHashMap 的扩容是支持并发的，可以大致分为三个步骤： 扩容准备1234 /** Number of CPUS, to place bounds on some sizings */ static final int NCPU = Runtime.getRuntime().availableProcessors(); private static final int MIN_TRANSFER_STRIDE = 16; 123456789101112131415161718private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { int n = tab.length, stride; //核数越大，就取(n &gt;&gt;&gt; 3) / NCPU，显然这个值会很小（如果n=16的话），没理解 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range //这里判断为null,确保只有一个线程获取 if (nextTab == null) { // initiating try { @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } NCPU是 返回可用处理器的Java虚拟机的数量 stride可以译为步幅，代表一个线程处理的节点数量，最小为16，在对多核处理器时，可以允许更大的步幅 transferIndex表示每次迁移任务的下标(从后往前)，如果是第一次那么为transferIndex到transferIndex - stride，每次任务分配完毕会被修改 这一步定义了之后会用到的相关变量，并允许有且只有一条线程来创建新的Node数组，方便迁移 迁移任务分配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);boolean advance = true;boolean finishing = false; // to ensure sweep before committing nextTabfor (int i = 0, bound = 0;;) { Node&lt;K,V&gt; f; int fh; while (advance) { int nextIndex, nextBound; //--i &gt;= bound代表的含义是不满足则表示代表当前任务完成，需要将i减一，然后advance设置为false,意为分配下一个任务，第一次进入就是这样，finishing为true代表整个扩容操作完成，自然不需要再操作 if (--i &gt;= bound || finishing) advance = false; //如果transferIndex&lt;0证明区间任务已经分配完毕，将advance设置为false,退出while循环，i设置为-1，在下方的if与剧中判断 else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } //CAS分配任务给各个线程 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { //最小下标 bound = nextBound; //最大下标 i = nextIndex - 1; // advance = false; } } //i&lt;0只可能是进入上面的第一种或者第二种情况，代表扩容结束或者分配完毕 //i &gt;= n感觉不可能出现这种情况，如前所述，那么只有i = nextIndex - 1这里赋值修改了i，而n就是table的长度，nextIndex只会越来越小 // if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { int sc; //如果扩容完成 if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; } //如果扩容未完成，修改sc的值，表示的协助扩容的线程数-1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { //不等于代表扩容未结束，直接return退出方法，否则就更新finishing表示扩容结束 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } //获取旧table的i位置的节点，如果是null,插入fwd表示已经扩容了 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //如果hash值是moved证明已被处理过，因为moved是表示该节点正在扩容，证明以有线程处理了 else if ((fh = f.hash) == MOVED) advance = true; // already processed ForwardingNode 前面说过表示该节点正在被迁移，在扩容之中，假设tableA中的i位置的节点正在或者已经被迁移到TableB中，那么i位置就会被放上一个ForwardingNode表示已经被迁移 advance 任务分配标识，true表示经分配完当前任务 finishing 扩容完成标识, true标识扩容完成 i 是位置索引，bound 是当前线程可以处理的当前任务区间最小下标 迁移12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 else { synchronized (f) { //再次判断节点是否相同 if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; //因为TreeBin 的 hash 是 -2，所以这里true代表是链表 if (fh &gt;= 0) { //这里结果只有两种一种是0一种为第n位为1的某个数 int runBit = fh &amp; n; //将第i位的节点复制给lastRun Node&lt;K,V&gt; lastRun = f; //遍历这个链表 for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } else if (f instanceof TreeBin) { TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } }} 其他情况表示该节点不为null,也没有moved,则将该节点锁住，防止其他线程在往其中插入数据 判断该节点是链表还是红黑树，分别处理 当为链表时，根据和table.length的与运算可以将链表一分为二","link":"/2018/12/03/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(%E4%BA%8C)/"},{"title":"HashMap实现原理","text":"前言今天去面试，之前也没有做什么准备，拿到面试题中有一题感觉很熟悉但是我不会，HashMap实现原理，回来后在网上看了一些文章，讲的还是比较详细的。 Hash表Hash表可以看作是一个综合考量的结果，我们知道数组是连续空间储存，是可以根据下标来找到相关的元素的，而链表是通过指针来指向其他的元素，对于一个元素来说只会知道相邻的元素是什么，在Java里面代表就是ArrayList和LinkedList，Hash表即横向为数组纵向为链表的形式，综合考量了查询以及插入和删除的速度。 HashMapNodeHashMap是存储键值对的集合，看了HashMap源码可以知道，事实上它是存储元素Node的数组，而Node实现了Map.Entry&lt;K, V&gt;接口，也就是说他可以看作是一个Entry数组。Node的构造分别由key、value、hash、和next而来 key和value分别是Node的键值 hash是有静态方法生成（见下方代码），若key是null，hash为0，不为null，hash是对h(key的hashcode值)和h移位16进行异或运算获得，原因后文解释 next是该索引下下一个Node的引用，指向下一个Node，next可以为null值，表示该索引下只有一个元素。 构造JDK的API表示HashMap可以指定初始容量 initialCapacity 和负载因子loadFactory，不指定则默认分别为16和0.75，初始容量制定了初始Node的数组大小，负载因子表示数组容量达到满溢的比例，当数组装满就会触发resize，扩容数组。 12345678910111213141516171819202122232425262728293031323334353637383940//静态内部类Nodestatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }} 12345678//hash的获取int hash = hash(key);static final int hash(Object key) { int h; //按位操作符，异或表示两者有一个是1，但不全为1，即为1，其他为0 //移位操作符，无符号右移16位 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 补充一下移位操作符 12345678910&lt;&lt; 左移运算符 相当于整个二进制数相对于小数点左移，即乘以2的次幂&gt;&gt; 右移运算符 相当于整个二进制数相对于小数点右移，即除以2的次幂的商&gt;&gt;&gt; 无符号右移 忽略符号位，空位都以0补齐对于正数来说&lt;&lt;&lt;和&lt;&lt;是一样的，但是对于负数来说，右移后的高位，&lt;&lt;是补上1，&lt;&lt;&lt;补上0举个栗子：-23在byte下的二进制表示为11101001，由23(00010111)取反加一得来-23&gt;&gt;2 = 11111010 = -122-23&gt;&gt;&gt;2 = 58可见区别无符号右移变味了正数 HashMap实现KEY的索引生成策略 对key取hashcode，得到h 对h和h右移16位进行异或运算，得到hash hash对Node数组长度取模，得到索引 1234567 /** * 获取key的索引 * JDK1.7的源码，1.8的没找到。。。 */static int indexFor(int h, int length) { return h &amp; (length-1);} put/get过程无论是put还是get,都需要先计算索引，获取到索引后，put先查看该索引下是否为null,如果是则直接插入，如果不为null，继续判断该Node是否存在现插入的key,存在则直接覆盖，不存在则先判断是链表还是红黑树，开始遍历，同样判定Node是否存在现插入的key，有则覆盖，无则插入到头部，期间一旦元素个数超过8个，都会转换为红黑树结构。 get先检查Node数组状态，到了到索引位置后，先判定第一个元素hash值是否相等，有直接取出，没有判定数据结构遍历一一比对，这里用到了逻辑操作符的短路特点，若hash不一致也没必要继续判定了 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} 两个问题 为什么要对h进行右移16位的异或运算，不能直接以hashcode作为key来使用？ 为什么取模是h &amp; (length-1)，不应该直接是h%length ？ 首先第一个问题，hashcode这个是通过hashcode()获取的，其结果是一个int型整数，而int的取值为-2^31-2^31,接近40亿，内存很难放下，设计者还认为这样的hashcode值还不足以分布均匀，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)是为了让低位区和高位区异或来融合各自的随机特性（16正好是32的一半），让hash变得更加的散第二的取模问题是因为容量一直2的次幂，length-1转换为一定是类似于0000000000001111的n个0和根号length个1，二者进行按位与运算后就获得了低位hash,而这恰恰是取模的余数，这样计算更加快捷 RESIZE当数组充满时就会触发扩容，数组长度变为之前的两倍，这个时候原来的索引就要重新计算，但是在HashMap这里同样有了小小的优化。 先说结论：重排后的索引要么时原位置，要么是原索引+原数组长度 原因：由于它的数组长度为2的次幂，计算到hash都是没有变化的，假设length = 2^k，取模时，之前的(2^k - 1)&amp;hash变成了(2^(k+1) - 1 )&amp;length，这里可以看出后者比前者大了2^k，那么都减一后后者会比前者多一个1，和hash进行按位与运算时，若hash该位置是1，那最后该位就是1，hash为0，最后就为0，转换为十进制就是一个原数组长度的区别。 相关 HashMap 实现原理 HashMap实现原理及源码分析 HashMap实现原理","link":"/2018/08/28/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"HEXO使用","text":"记录HEXO使用 HEXO添加点击爱心效果 在/themes/next/source/js/src下新建文件clicklove.js，接着把下面的代码拷贝粘贴到clicklove.js文件中 1!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 在\\themes\\next\\layout\\_layout.swig文件末尾添加 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/clicklove.js\"&gt;&lt;/script&gt; 添加不蒜子网站计数及修复 NexT主题相关 1由于七牛云回收不蒜子测试域名，导致不蒜子更改了域名，以下域名是修改过的 找到站点的themes/next/layout/_partials目录下的footer.swig文件插入代码如下 1234567891011121314151617181920212223242526272829303132{% if theme.footer.powered %} &lt;div class=\"powered-by\"&gt;{# #}{{ __('footer.powered', '&lt;a class=\"theme-link\" target=\"_blank\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') }}{##}&lt;/div&gt;{% endif %}{% if theme.footer.powered and theme.footer.theme.enable %} &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;{% endif %}{% if theme.footer.theme.enable %} &lt;div class=\"theme-info\"&gt;{# #}{{ __('footer.theme') }} &amp;mdash; {# #}&lt;a class=\"theme-link\" target=\"_blank\" href=\"https://github.com/iissnan/hexo-theme-next\"&gt;{# #}NexT.{{ theme.scheme }}{# #}&lt;/a&gt;{% if theme.footer.theme.version %} v{{ theme.version }}{% endif %}{##}&lt;/div&gt;{% endif %}&lt;!-- 插入网站计数 --&gt;&lt;div&gt;&lt;script async src=\"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;总访问量 &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/div&gt;{% if theme.footer.custom_text %} &lt;div class=\"footer-custom\"&gt;{# #}{{ theme.footer.custom_text }}{##}&lt;/div&gt;{% endif %} 添加阅读进度显示NexT主题相关 找到站点的/blog/themes/next目录下的_config.yml文件修改代码如下 12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 添加社交外链NexT主题相关 找到站点的/blog/themes/next目录下的_config.yml文件搜索social模块添加内容如下 1234social: 豆瓣: https://www.douban.com/people/176248529/ || douban 网易云: https://music.163.com/#/user/home?id=73195716 || music GitHub: https://github.com/bwensun || github 这里需要注意的是，网上很多教程都是在social icon上面加图标，我试了无效，正解是以双竖线分割后面填写icon名称，这样可以生效，具体选择什么样的图标，可以登录fontawesome查看图标 添加音乐外链NexT主题相关 访问网易云音乐，选择你喜欢的音乐，点击生成外链播放器，复制外联播放器代码 修改 blog\\themes\\next\\layout\\_macro的sidebar.swig文件，添加刚刚复制的外链代码 值得注意的是，这个功能会在打开网页时直接播放，有些音乐在网易云中是无法生成外链播放器的 设置背景NexT主题相关 把你挑选的背景图片命名为放在blog\\themes\\next\\source\\images里在blog\\themes\\next\\source\\css_custom文件的custom.styl首部添加如下内容 1234body { background:url(/images/图片名称); background-attachment: fixed;} 值得注意的是，直接部署在github上的项目首次加载会慢的离谱，也许会是一分多钟 添加评论系统Valine添加之前请先确认主题是否支持，NEXT主题是支持的 Valine评论系统真的很好用，非常轻量，支持头像，emoji表情还有markdown语法，速度也很快，推荐 注册Leancloud账号 LearnCloud注册 配置Leancloud 创建应用 创建Class 修改主题配置文件 打开站点的/blog/themes/next目录下的_config.yml文件，搜索valine 将enable属性设置为true表示开启，将appid和appkey填入主题配置文件，verify表示用户评论会先出现校验吗进行校验，avatar为头像的风格 这里是retro,更多配置项可以见:配置项 以下是我的配置 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: 略 # your leancloud application appid appkey: 略 # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 说点什么吧... # comment box placeholder avatar: retro # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 修改字体 NexT主题相关 字体修改在/themes/hexo-theme-next/source/css/_variables下的custom.styl文件中 12$font-family-headings = Georgia, sans // 标题，修改成你期望的字体族$font-family-base = \"Microsoft YaHei\", Verdana, sans-serif // 修改成你期望的字体族 12345678910111213141516171819202122232425262728293031323334353637383940新细明体：PMingLiU 细明体：MingLiU 标楷体：DFKai-SB 黑体：SimHei 宋体：SimSun 新宋体：NSimSun 仿宋：FangSong 楷体：KaiTi 仿宋_GB2312：FangSong_GB2312 楷体_GB2312：KaiTi_GB2312 微软正黑体：Microsoft JhengHei 微软雅黑体：Microsoft YaHei 装Office会多出来的一些字体： 隶书：LiSu 幼圆：YouYuan 华文细黑：STXihei 华文楷体：STKaiti 华文宋体：STSong 华文中宋：STZhongsong 华文仿宋：STFangsong 方正舒体：FZShuTi 方正姚体：FZYaoti 华文彩云：STCaiyun 华文琥珀：STHupo 华文隶书：STLiti 华文行楷：STXingkai 华文新魏：STXinwei 苹果电脑中的字体： 华文细黑：STHeiti Light [STXihei] 华文黑体：STHeiti 华文楷体：STKaiti 华文宋体：STSong 华文仿宋：STFangsong 丽黑 Pro：LiHei Pro Medium 丽宋 Pro：LiSong Pro Light 标楷体：BiauKai 苹果丽中黑：Apple LiGothic Medium 苹果丽细宋：Apple LiSung Light 字体大小在/themes/hexo-theme-next/source/css/_variables下的base.styl 12345678910111213141516171819202122232425// Font Weight$font-weight-lighter = 200$font-weight-light = 300$font-weight-normal = 400$font-weight-bold = 600$font-weight-bolder = 700// Font size$font-size-base = 14px$font-size-base = unit(hexo-config('font.global.size'), px) if hexo-config('font.global.size') is a 'unit'$font-size-small = $font-size-base - 2px$font-size-smaller = $font-size-base - 4px$font-size-large = $font-size-base + 2px$font-size-larger = $font-size-base + 4px// Headings font size$font-size-headings-step = 2px$font-size-headings-base = 24px$font-size-headings-base = unit(hexo-config('font.headings.size'), px) if hexo-config('font.headings.size') is a 'unit'$font-size-headings-small = $font-size-headings-base - $font-size-headings-step$font-size-headings-smaller = $font-size-headings-small - $font-size-headings-step$font-size-headings-large = $font-size-headings-base + $font-size-headings-step$font-size-headings-larger = $font-size-headings-large + $font-size-headings-step hexo默认字体不错，只是英文字体不是很好看 相关 Hexo博客之改字体","link":"/2019/02/23/Hexo%E4%BD%BF%E7%94%A8/"},{"title":"Java8 流式API","text":"为什么引入流式API在java中对于数据的操作常常是借助数据库来做到的，java自带的集合操作方法是不能对于大数据量的数据进行各种操作，常常要做的就是遍历再遍历，另外java中集合操作无法支持并行执行，流式API的出现可以发挥多核处理器的优势 使用构建stream 静态工厂方法(Stream) of方法方法参数也可以将数组或者集合，转换为流,Java中流对象只有IntStream，DoubleStream和StringStream 1IntStream intStream = of(1, 2, 3); generate方法 该方法用于随机数产生，或者常量Stream等，返回无限长度的流最好借助lambda表达式 12Stream&lt;Double&gt; stream2 = Stream.generate(() -&gt; Math.random());Stream&lt;Double&gt; stream3 = Stream.generate(Math::random); iterate方法： 1Stream.iterate(0, x -&gt; x++); empty方法：返回一个一个空的流 1Stream&lt;Object&gt; empty = Stream.empty(); 集合和数组调用stream()方法 stream的操作 流的操作分为两种： Intermediate： map 、filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential Terminal：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、iteratorIntermediate中间操作不会导致流的消失，返回值为stream，Terminal操作结束后流即消失了 stream使用示例demo数据如下： 12345678910List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(\"孙博文\", 1)); list.add(new User(\"孙博文\", 2)); list.add(new User(\"孙博文\", 3)); list.add(new User(\"张三\", 11)); list.add(new User(\"张三\", 12)); list.add(new User(\"张三\", 13)); list.add(new User(\"李文博\", 21)); list.add(new User(\"李文博\", 22)); list.add(new User(\"李文博\", 23)); map：输入流中元素执行操作后一一映射输出流的元素，这个经常会用到，尤其是再将对象的集合转变为对象中属性的集合，另外map经常和reduce操作混合使用来归并数据 12List&lt;Integer&gt; ageList1 = list.stream().map(x -&gt; x.getAge()).collect(Collectors.toList());List&lt;Integer&gt; ageList2 = list.stream().map(User::getAge).collect(Collectors.toList()); filter：条件为布尔值，将满足条件的过滤出来 1List&lt;User&gt; collect = list.stream().filter(x -&gt; x.getAge() &gt; 0).collect(Collectors.toList()); distinct：去重，就可以看作放到set集合之中，但有序 1list.stream().distinct().forEach(x-&gt; System.out.println(x)); sorted：排序，基本数据类型是可以比较的（我没测全），对象直接比较会报错，需要自己实现比较器 123456789List list1 = new ArrayList&lt;&gt;(); list1.add(3); list1.add(1); list1.add(4); list1.stream().sorted().forEach(x -&gt; System.out.println(x)); list.stream().map(User::getName).sorted().forEach(x -&gt; System.out.println(x)); list.stream().sorted((x, y)-&gt;(x.getName().compareToIgnoreCase(y.getName()))).forEach(x -&gt; System.out.println(x)); peek：用的不多，一般用来查看元素和打印元素，他和foreach的区别在于它只是中间操作，流依然存在 1List&lt;User&gt; userList1 = list.stream().distinct().peek(x -&gt; System.out.println(x)).collect(Collectors.toList()); limit/skip：截断流，区别在于limit截取前几个元素返回流，而skip是跳过前几个元素返回流 1list.stream().limit(6).skip(3).forEach(x -&gt; System.out.println(x.getName())); parallel/sequential：并行流和串行流的互转，parallel将串行流转换为并行流，sequential将并行流转换为串行流，并行流不在乎保持最终的次序，所以更加快，但有时候顺序可能有误，串行流会维持最初的顺序，我用的不多 forEach：和peek类似只是为终端操作 forEachOrdered：foreach+sorted toArray：归并流为数组reduce：可以理解为将初始值，按照一定的规则，对每一个流中的元素迭代的执行，直至到最后，使用非常广泛，它的完整版接受三个参数：reduce(identity, accumulator, combiner),第一个参数为初始值，第二个为迭代操作，第三个为多个迭代结果的合并操作，另外两个方法都是其简略版,(accumulator)和(identity,accumulator)，事实上min,max,count都是reduce操作,值得注意的是combiner的作用是将并行流的处理结果归并时的执行策略，我基本不用，也不说了，免得写错了 12345678910//求和(因为没有初始值，可能出现null，所以返回的optional)Integer sum1 = list.stream().map(User::getAge).reduce(Integer::sum).get();//完整版Integer sum2 = list.stream().map(User::getAge).reduce(0, (x, y) -&gt; y = y + x);//求最小值list.stream().map(User::getAge).reduce(Integer::min).get();//求最大值list.stream().map(User::getAge).reduce(Integer::max).get();//字符串拼接String s = list.stream().map(User::getName).reduce(String::concat).get(); max/min：如上所述，一种特殊的reduce操作，取出最大或者最小值，用法较简单 match：返回值为布尔类型，它包括有allMatch(全部满足返回true），anyMatch(任意一个满足返回true),noneMatch(没有一个满足返回true) collect：它和reduce一样重要，将流的结果处理为定义的类型，继续介绍完整版方法collect(supplier, accumulator, combiner) 对于list而言，第一个为想要获取的结果类型，使用new语法获取对象；第二个为将当前元素添加到目标中的方法；第三个为将修改后的对象转为自定义对象方法； 1234//重载版List&lt;Integer&gt; ageList1 = list.stream().map(x -&gt; x.getAge()).collect(Collectors.toList());//完整版ArrayList&lt;User&gt; users = list.stream().collect(ArrayList&lt;User&gt;::new, ArrayList::add, ArrayList::addAll); 对于map集合而言，第一个参数为key的映射，第二个为value的映射，第三个为key相同时的处理策略 1list.stream().collect(Collectors.toMap(User::getName, User::getAge, (K1, K2) -&gt; K1)); 进阶用法直接分组1Map&lt;String,List&lt;User&gt;&gt;collect=list.stream().collect(Collectors.groupingBy(x-&gt;x.getName())); 按照姓名分组计数求和12345 //这是个重载的方法 Map&lt;String, Long&gt; collect1 = list.stream(). collect(Collectors.groupingBy(x -&gt; x.getName(), Collectors.counting())); Map&lt;String, Integer&gt; collect2 = list.stream() .collect(Collectors.groupingBy(x -&gt; x.getName(), Collectors.summingInt(user -&gt; user.getAge()))); collectAndThen迭代生成流的处理：它比前者要多出一个流处理位置123456789 //组内top值 list.stream(). collect(Collectors.groupingBy(User::getName,Collectors.maxBy(Comparator.comparingInt(User::getAge)))) .forEach((name, maxAge) -&gt; System.out.println(\"姓名：\"+name+ \"----\"+ \"最大年龄\" + maxAge.get().getAge())); list.stream() .collect(Collectors .groupingBy(User::getName, Collectors .collectingAndThen(Collectors.maxBy(Comparator.comparingInt(User::getAge)), x-&gt;x.get().getAge()))) .forEach((name, maxAge) -&gt; System.out.println(\"姓名：\"+name+ \"----\"+ \"最大年龄\" + maxAge)); 相关 Java 8 中的 Streams API 详解","link":"/2019/04/01/Java8-%E6%B5%81%E5%BC%8FAPI/"},{"title":"存储引擎:InnoDB和MyISAM","text":"前言看高性能MySQL有些疑问，查阅记录下来。 InnoDB存储引擎历史早在MySQL5.1时，InnoDB是作为一个插件来扩展MySQL的功能的，MySQL内部依旧是用的老版本的InnoDB,原因是因为其版权是归有Oracle所有（当时sun还没有被收购），后来sun被收购以后版本的MySQL也就是5.5以后，都是使用的InnoDB来作为默认的存储引擎，现在大多企业用的都是MySQL5.7版本，扩展了更多的新特性。 概览InnoDB数据存储在表空间，有一系列数据文件组成。 InnoDB以MVCC来支持高并发，实现了是个数据隔离级别，默认隔离级别是可重复读，需要注意的是它通过间隙锁来防止出现的幻读现象，间隙锁不仅仅锁定查询时的行，还对索引中的间隙进行锁定。 InnoDB做了很多优化，其中的表是基于聚簇索引建立的，对主键查询具有很高的性能，它可以自动的创建自适应哈希索引，关于它的索引以后再介绍。 123456789101112131415161718MVCC（多版本并发控制）： InnoDB事务的实现不仅仅是行级锁，也通过MVCC实现了非阻塞的读操作， 正常情况下当已存在数据的写入时，读操作涉及到相关行时会被阻塞的， 但是通过MVCC让读操作依旧可以读取到正确的数据。可重复读的实现： 通过在每行记录后添加两个隐藏的列，分别是行的行版本号， 和行的删除版本号，只要增删改查满足一定的规则， 那么大部分的查询操作都没有必要加锁。规则： select： 1. 只查询行的行版本号小于或者等于当前事务版本号 2. 行的删除版本号要么未定义，要么大于当前事务版本号 insert: 1. 插入的每一行都保存当前事务版本号为行版本号 delete: 1. 删除的每一行都保存当前事务版本号为行的删除版本号 update: 1. 保存当前事务版本号为行的型版本号和删除版本号 123456间隙锁： 当使用范围条件检索数据，或者相等条件的一个不存在记录， InnoDB会将范围内所有数据加锁。这样做一方面是为了防止幻读 （比如查询年龄大于20，那么之后有数据插入年龄大于20会直接失败）， 另一方面为了恢复和复制数据（因为MySQL时按照BINLOG中的SQL和 事务的提交顺序来恢复的，Oracle是以数据块和系统更新号SCN来恢复的；）。 MyISAM存储引擎存储MyISAM是MySQL5.1和之前的默认存储引擎，将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为扩展名，它可以压缩表，但是被压缩的表是无法被修改的，但是可以解压缩。 特性 加锁是对整张表加锁，不支持行级锁 不支持事务，崩溃后修复可能会丢失数据，因为没有MVCC 支持全文索引，可以延迟更新索引键 相关 MySQL学习之——锁(行锁、表锁、页锁、乐观锁、悲观锁等) 高性能MySQL","link":"/2018/09/05/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9AInnoDB%E5%92%8CMyISAM/"},{"title":"记七牛云回收测试域名导致博客图片丢失","text":"前言一段时间没有更新博客，昨天发现自己的博客图片已经无法显示了，我的图片是引用七牛云图床的外链，怎么回事？登录上发现，自己的测试域名已经被回收了，虽然也发了邮件，但是就这么回收了，图片也没了，心情就是日了狗的感觉。 改用腾讯云Google了一下，七牛云建议用户自己绑定域名，这样也罢了，需要保持自己账号有10元余额，关键域名也要备案，填写企业名等信息，算了，直接拜拜，直接弃用！ 其他的一些小型的图床网站我也不敢用了，指不定哪天直接挂了，图片上哪里找去，阿里的OSS也有人用，但是它的计费方式有点复杂，综合之下自己还是用了腾讯的OCS,计费规则也比较良心，腾讯云回访时问了客服，域名时不会回收的，只需免费完成后继续缴费即可。 具体申请方法如下： 首先注册腾讯云账号，账号可以是QQ或者微信均可，完成实名认证。 进入COS对象存储控制台，存储桶列表，创建新的存储桶 在该存储桶内，你可以定义自己文件列表 下载适配版本的COS桌面版，提高效率 注意： 1. 和七牛云不同的时，直接在浏览器输入url不是预览而是下载，所以放心的把图片放上去就行了 2. 腾讯云的API非常完善，关于上传文件，防盗链等等都可以直接查看腾讯云官方文档是最好的","link":"/2018/11/26/%E8%AE%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%9E%E6%94%B6%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E5%AF%BC%E8%87%B4%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%A2%E5%A4%B1/"},{"title":"Nexus搭建maven私服","text":"前言使用nexus2.14版本搭建maven私服，中间踩了一些坑，记录下来，nexus3.x 版本和nexus差别还是不小的，尤其是索引的更新。 2019-04-15更新，看完《maven实战》后修改 私服的概念和我们为什么要配私服什么是私服私服可以看作是一个仓库，项目开发时总是要需要构件的，配置在局域网内的私服可以让局域网内所有用户请求构件，而不必频繁的访问中央仓库（众所周知，maven中央仓库的速度），升值有些开发环境时不允许开发人员连接外网的，那么开发人员的唯一远程仓库就是私服，私服从外部下载构件 为什么配私服出了上述的原因之外，私服更有协议maven中央仓库没有的优势，比如开发人员可以将项目打包部署到私服，供其他人员使用，一些小众的jar包可以手动上传至私服总的来说，一般大一些的项目都会配置 下载安装 下载nexus2.14版本，下载链接：nexus2.14下载 下载完成后解压得到两个文件夹，一个安装目录一个work目录，进入安装目录、bin、jsw，选择和自己操作系统匹配的文件夹进入 注意： 这里尤其注意的是不能解压在包含中文字符的目录下，否则启动会报一个无法打开日志文件的错误!!! 我安装在windows上的，进入windows_64x，可以看到有多个命令，介绍如下 1234567console-nexus.bat 以命令窗口的形式启动，关闭后服务停止install-nexus.bat 设置开机启动，在服务中可以看成到该服务为开机自动启动stop-nexus.bat 停止服务uninstall-nexus.bat 卸载nexus 双击启动nexus，打开游览器输入http://192.168.88.16:8081/nexus/，出现以下页面表示启动成功 至此nexus安装启动成功 Nexus页面介绍Repositories这个是nexus最核心的功能，在这里可以创建仓库，配置仓库属性![]https://blog-1258374330.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2/nexus%E6%90%AD%E5%BB%BAmaven%E7%A7%81%E6%9C%8D/Snipaste_2019-04-15_14-48-11.png) 仓库介绍可以看到仓库一般分为三种，hosted宿主仓库，proxy代理仓库以及virtural的虚拟仓库，所谓宿主将库，就是用于将构件上传至maven私服的仓库，一般我们配置上releases和snapshots两个，而代理仓库就是用于下载外部构件的远程库，aliyun镜像仓库就是一个代理仓库，virtural的虚拟仓库仅仅是逻辑上的仓库，他可能两个仓库合并 1234567891011121314151617介绍一下仓库的属性： Type: group（仓库组）:组合各个仓库一同向外提供服务 hosted（宿主）：用于发布内部项目构件或第三方的项目构件，还有私服的配置 proxy（代理）：代理远程仓库 virtual（虚拟）： ID： 唯一标识 Name: 解释说明 Provider: 一般都用Maven2 Repository Policy： Snapshot:快照 Release:稳定 Deployment Policy： 是否允许重新部署，这在部署构件到远程仓库时需要开启 更新索引 注意更新索引的意义仅仅在于搜索而已，事实上我们不更新索引也是没关系的，只要下载了相关jar包，点击rebuild index就可以将已下载的jar包索引构建完毕， 登录 管理员账号登录，用户名admin，密码admin123 更新索引 一般我们初次启动nexus时，center仓库是空的，而索引可以看作是压缩版的jar包集合，让我们可以从本地的远程库中拉取依赖，可以在configuration中配置索引的自动更新，但是这样下载速度奇慢无比，而且容易卡死，这在scheduled task可以看到update index一直处于running状态，这里比较推荐手动更新，网上的步骤说的都很详细 下载相关文件 三个文件，分别是nexus-maven-repository-index.gz，nexus-maven-repository-index.properties以及ndexer-cli-5.1.1.jar，这在我的百度网盘中都保存了，下载链接： 解压索引文件 三个文件放到同一目录下，执行：java -jar indexer-cli-5.1.1.jar -u nexus-maven-repository-index.gz -d indexer 解压完毕后把indexer文件夹里面的文件拷贝到{nexus-home}/sonatype-work/nexus/indexer/central-ctx目录下，重新启动nexus 当我们更新索引成功后，可以在Browse Index后选项卡看到许多文件 搭建私服仓库我们先建立一个aliyun的代理仓库，id为aliyun，仓库地址为 阿里云仓库；在配置两个hosted宿主仓库用以发布构件到maven私服，版本分别为snapshots和releases，deployment属性为allow允许部署；再新建一个仓库组将这些都加入，包括中央仓库，调整它的顺序，它的顺序就是maven依赖选择下载的顺序，一般我们将阿里云的代理仓库置于中央仓库之上 注意：上传那么就要把Deployment Policy改为允许上传 私服仓库配置添加仓库为私服仓库这里既可以配置在settings.xml中，也可以配置pom.xml中一般建议写在setting.xml之中 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 定义一些属性配置 --&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus-profile&lt;/id&gt; &lt;repositorys&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/nexus/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositorys&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/nexus/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;!-- 激活 --&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;nexus-profile&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 写在pom.xml之中 12345678910111213141516171819202122232425 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;film-group&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/film-group/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;film-group&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/film-group/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 仓库标签下有些属性还是要介绍下的 123456789101112id：仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central， 如果其他仓库声明也使用该id，就会覆盖中央仓库的配置name：仓库的名称，让我们直观方便的知道仓库是哪个url：指向了仓库的地址，一般来说，该地址都基于http协议， Maven用户都可以在浏览器中打开仓库地址浏览构件。releases和snapshots：用来控制Maven对于发布版构件和快照版构件的下载权限。 需要注意的是enabled子元素，该例中releases的enabled值为true， 表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false， 表示关闭JBoss仓库的快照版本的下载支持。根据该配置， Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。layout：元素值default表示仓库的布局是Maven2及Maven3的默认布局， 而不是Maven1的布局。基本不会用到Maven1的布局 至此，大部分请求会请求苏福，但是想要屏蔽所有请求到私服的话，还需要配置镜像 先配置镜像用以屏蔽所有仓库的请求，转至私服在settings.xml中，配置如下： 12345678 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/nexus/&lt;/url&gt;; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; mirrorOf配置规则 1234&lt;mirrorOf&gt;*&lt;mirrorOf&gt;:匹配所有远程仓库。&lt;mirrorOf&gt;external:*&lt;mirrorOf&gt;:匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。&lt;mirrorOf&gt;repo1,repo2&lt;mirrorOf&gt;:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。&lt;mirrorOf&gt;*,!repo1&lt;mirrorOf&gt;:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。 配置仓库为私服仓库这里已经可以完成构件使用的功能了，想要上传构建需要继续配置 部署构件到私服就是把本项目上传到maven pom.xml中配置构件上传的地址123456789101112 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;film-releases&lt;/id&gt; &lt;name&gt;nexus_repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/film-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;film-snapshots&lt;/id&gt; &lt;name&gt;nexus_repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/film-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 在settings.xml中配置认证信息123456789101112 &lt;servers&gt; &lt;server&gt; &lt;id&gt;film-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;film-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 更多搭建私服的过程和使用的基本配置介绍完毕更多的权限的细节控制，定时任务的执行，还有maven的一些基础只是就不必介绍了 相关 《maven实战》 持续集成-Sonatype Nexus安装 Maven入门，读完这篇就够了","link":"/2018/10/25/Nexus%E6%90%AD%E5%BB%BAmaven%E7%A7%81%E6%9C%8D/"}],"tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","link":"/tags/ConcurrentHashMap/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"Lamda","slug":"Lamda","link":"/tags/Lamda/"},{"name":"存储引擎","slug":"存储引擎","link":"/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"maven私服搭建","slug":"maven私服搭建","link":"/tags/maven%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"}],"categories":[{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"java8","slug":"java8","link":"/categories/java8/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"}]}